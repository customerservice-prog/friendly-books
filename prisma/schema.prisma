generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum BusinessUse {
  yes
  no
  unsure
}

enum ClassificationSource {
  user_lock
  rule
  merchant_memory
  provider_mapping
  heuristic
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  passwordHash String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // NextAuth
  authAccounts AuthAccount[]
  sessions     Session[]

  // App
  accounts     Account[]
  items        Item[]
  txns         Transaction[]
  rules        Rule[]
  labels       Label[]
  merchants    MerchantStat[]

  @@index([createdAt])
}

model AuthAccount {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Institution {
  id                     String   @id @default(cuid())
  name                   String
  providerInstitutionId  String
  createdAt              DateTime @default(now())

  accounts               Account[]

  @@unique([providerInstitutionId])
}

model Item {
  id                String   @id @default(cuid())
  userId            String
  provider          String   // plaid | mock
  providerItemId    String
  accessTokenEnc    String
  status            String   @default("active")
  cursor            String?  // for incremental sync
  lastSyncAt        DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  accounts          Account[]

  @@index([userId])
  @@unique([provider, providerItemId])
}

model Account {
  id                 String   @id @default(cuid())
  userId             String
  institutionId      String?
  itemId             String?

  providerAccountId  String
  name               String
  type               String
  subtype            String?
  maskLast4          String?
  isBusinessDefault  Boolean  @default(false)
  createdAt          DateTime @default(now())

  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  institution        Institution? @relation(fields: [institutionId], references: [id], onDelete: SetNull)
  item               Item?    @relation(fields: [itemId], references: [id], onDelete: SetNull)

  txns               Transaction[]

  @@index([userId])
  @@unique([userId, providerAccountId])
}

model Transaction {
  id                    String   @id @default(cuid())
  userId                String
  accountId             String

  provider              String   // plaid | mock
  providerTransactionId String

  datePosted            DateTime
  dateAuthorized        DateTime?
  amount                Decimal  @db.Decimal(14,2) // outflow positive, inflow negative
  currency              String   @default("USD")
  nameRaw               String
  merchantName          String?
  merchantKey           String
  mcc                   String?
  providerCategory      Json?
  pending               Boolean  @default(false)
  paymentChannel        String?
  location              Json?

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  account               Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)

  classification        Classification?
  labels                Label[]

  @@index([userId, datePosted])
  @@unique([provider, providerTransactionId])
}

model Classification {
  transactionId   String   @id
  businessUse     BusinessUse @default(unsure)
  taxCategory     String?  // e.g. FUEL, EQUIPMENT
  confidence      Float    @default(0)
  reason          String   @default("")
  engineVersion   String   @default("v1")
  locked          Boolean  @default(false)
  source          ClassificationSource @default(heuristic)
  updatedAt       DateTime @updatedAt

  transaction     Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@index([businessUse])
  @@index([taxCategory])
}

model Label {
  id            String   @id @default(cuid())
  transactionId String
  userId        String

  businessUse   BusinessUse
  taxCategory   String?
  note          String?

  createdAt     DateTime @default(now())

  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model Rule {
  id        String   @id @default(cuid())
  userId    String
  priority  Int      @default(100)
  enabled   Boolean  @default(true)
  match     Json
  set       Json
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, priority])
}

model MerchantStat {
  id           String   @id @default(cuid())
  userId       String
  merchantKey  String
  businessYes  Int      @default(0)
  businessNo   Int      @default(0)
  unsure       Int      @default(0)
  topTaxCategory String?
  updatedAt    DateTime @updatedAt

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, merchantKey])
}
